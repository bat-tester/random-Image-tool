<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Random Image Storage</title>
  
  <!-- PWA Configuration -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#1e293b">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Image Storage">
  <link rel="apple-touch-icon" href="icon-192.png">
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // Lucide React icons as inline SVGs
    const Trash2 = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <polyline points="3 6 5 6 21 6"></polyline>
        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        <line x1="10" y1="11" x2="10" y2="17"></line>
        <line x1="14" y1="11" x2="14" y2="17"></line>
      </svg>
    );

    const Download = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="7 10 12 15 17 10"></polyline>
        <line x1="12" y1="15" x2="12" y2="3"></line>
      </svg>
    );

    const Upload = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
      </svg>
    );

    const AlertCircle = ({ size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="12" y1="8" x2="12" y2="12"></line>
        <line x1="12" y1="16" x2="12.01" y2="16"></line>
      </svg>
    );

    // LocalStorage-based storage implementation
    window.storage = {
      get: async (key) => {
        const value = localStorage.getItem(key);
        return value ? { key, value, shared: false } : null;
      },
      set: async (key, value) => {
        localStorage.setItem(key, value);
        return { key, value, shared: false };
      },
      delete: async (key) => {
        localStorage.removeItem(key);
        return { key, deleted: true, shared: false };
      },
      list: async (prefix) => {
        const keys = Object.keys(localStorage).filter(k => !prefix || k.startsWith(prefix));
        return { keys, prefix, shared: false };
      }
    };

    function ImageStorage() {
      const [images, setImages] = useState([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState('');
      const [uploading, setUploading] = useState(false);
      const [uploadSuccess, setUploadSuccess] = useState(false);
      const [uploadStats, setUploadStats] = useState(null);
      const [uploadError, setUploadError] = useState(null);
      const [failedFiles, setFailedFiles] = useState([]);
      const [activeTab, setActiveTab] = useState('home');
      const [viewingImage, setViewingImage] = useState(null);
      const [randomSlideshow, setRandomSlideshow] = useState(false);
      const [shuffledImages, setShuffledImages] = useState([]);
      const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
      const [deleteAllCode, setDeleteAllCode] = useState('');
      const [showDeleteAllPrompt, setShowDeleteAllPrompt] = useState(false);
      const [selectedCategory, setSelectedCategory] = useState('2');
      const [filterCategory, setFilterCategory] = useState('ALL');
      const [innerSlideIndex, setInnerSlideIndex] = useState(0);
      const [touchStart, setTouchStart] = useState(0);
      const [touchEnd, setTouchEnd] = useState(0);

      useEffect(() => {
        loadImages();
        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('/service-worker.js')
            .then(reg => console.log('Service Worker registered'))
            .catch(err => console.log('Service Worker registration failed'));
        }
      }, []);

      useEffect(() => {
        setInnerSlideIndex(0);
      }, [currentSlideIndex]);

      const loadImages = async () => {
        try {
          const result = await window.storage.get('random-images');
          if (result) {
            const imgs = JSON.parse(result.value);
            setImages(imgs);
          }
        } catch (err) {
          console.error('Error loading:', err);
          setError('Failed to load images');
        }
        setLoading(false);
      };

      const saveImages = async (newImages) => {
        try {
          await window.storage.set('random-images', JSON.stringify(newImages));
          setImages(newImages);
        } catch (err) {
          setError('Failed to save images');
        }
      };

      const compressImage = (base64, quality = 0.3, scale = 0.75) => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            try {
              const canvas = document.createElement('canvas');
              canvas.width = img.width * scale;
              canvas.height = img.height * scale;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              resolve(canvas.toDataURL('image/jpeg', quality));
            } catch (err) {
              reject(err);
            }
          };
          img.onerror = () => reject(new Error('Failed to load image'));
          img.src = base64;
        });
      };

      const analyzeImageError = (error, fileSize, fileName) => {
        if (fileSize > 10 * 1024 * 1024) {
          return {
            reason: 'File too large',
            advice: `"${fileName}" is ${(fileSize / 1024 / 1024).toFixed(1)}MB. Try a smaller image (under 10MB) or take a new screenshot.`
          };
        }
        if (error.message.includes('quota') || error.message.includes('storage')) {
          return {
            reason: 'Storage full',
            advice: 'Your browser storage is full. Delete some old images to free up space.'
          };
        }
        if (error.message.includes('load')) {
          return {
            reason: 'Invalid image format',
            advice: `"${fileName}" might be corrupted or in an unsupported format. Try taking a new screenshot.`
          };
        }
        return {
          reason: 'Upload failed',
          advice: `Could not process "${fileName}". Try: 1) Taking a new screenshot, 2) Restarting the app, 3) Checking available storage.`
        };
      };

      const uploadSingleImage = async (file, groupId, orderCounter, attemptNumber = 1) => {
        const maxAttempts = 3;
        const compressionStrategies = [
          { quality: 0.3, scale: 0.75 },  // Default: moderate compression
          { quality: 0.2, scale: 0.6 },   // Aggressive compression
          { quality: 0.1, scale: 0.5 }    // Maximum compression
        ];

        for (let attempt = attemptNumber - 1; attempt < maxAttempts; attempt++) {
          try {
            const strategy = compressionStrategies[attempt];
            const reader = new FileReader();
            
            const base64 = await new Promise((resolve, reject) => {
              reader.onload = () => resolve(reader.result);
              reader.onerror = () => reject(new Error('Failed to read file'));
              reader.readAsDataURL(file);
            });

            const compressed = await compressImage(base64, strategy.quality, strategy.scale);
            const size = (compressed.length * 0.75) / 1024;

            // Try to save to test storage capacity
            const testKey = 'test-capacity-' + Date.now();
            await window.storage.set(testKey, compressed);
            await window.storage.delete(testKey);

            return {
              id: groupId + orderCounter,
              name: file.name,
              base64: compressed,
              uploadedAt: new Date().toLocaleString(),
              size: size.toFixed(2) + ' KB',
              groupId: groupId,
              groupSize: 1, // Will be updated later
              groupOrder: orderCounter,
              category: selectedCategory,
              compressionLevel: attempt + 1
            };
          } catch (err) {
            console.error(`Attempt ${attempt + 1} failed for ${file.name}:`, err);
            if (attempt === maxAttempts - 1) {
              throw err;
            }
            // Wait before retry
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        }
      };

      const handleImageUpload = async (e) => {
        const files = Array.from(e.target.files);
        if (!files.length) return;

        setUploading(true);
        setError('');
        setUploadError(null);
        setFailedFiles([]);

        const previousSize = images.reduce((s, img) => s + parseFloat(img.size), 0);

        try {
          const newImages = [...images];
          const groupId = Date.now();
          const failed = [];
          let successCount = 0;

          for (let i = 0; i < files.length; i++) {
            try {
              const imageData = await uploadSingleImage(files[i], groupId, i);
              imageData.groupSize = files.length;
              newImages.push(imageData);
              successCount++;
            } catch (err) {
              const errorInfo = analyzeImageError(err, files[i].size, files[i].name);
              failed.push({
                file: files[i],
                name: files[i].name,
                reason: errorInfo.reason,
                advice: errorInfo.advice,
                groupId: groupId,
                orderCounter: i
              });
            }
          }

          if (successCount > 0) {
            await saveImages(newImages);
            const newSize = newImages.reduce((s, img) => s + parseFloat(img.size), 0);
            setUploadStats({
              count: successCount,
              previousSize: (previousSize / 1024).toFixed(2),
              newSize: (newSize / 1024).toFixed(2)
            });
            setUploadSuccess(true);
            setTimeout(() => {
              setUploadSuccess(false);
              setUploadStats(null);
            }, 5000);
          }

          if (failed.length > 0) {
            setFailedFiles(failed);
            setUploadError(`${failed.length} image${failed.length > 1 ? 's' : ''} failed to upload`);
          }

          setUploading(false);
          e.target.value = '';
        } catch (err) {
          setError('Upload failed completely. Please try again.');
          setUploading(false);
        }
      };

      const retryFailedUpload = async (failedFile) => {
        setUploading(true);
        setUploadError(null);

        try {
          const imageData = await uploadSingleImage(
            failedFile.file,
            failedFile.groupId,
            failedFile.orderCounter
          );
          imageData.groupSize = 1; // Single retry
          
          const newImages = [...images, imageData];
          await saveImages(newImages);

          // Remove from failed list
          setFailedFiles(prev => prev.filter(f => f.name !== failedFile.name));
          
          setUploadSuccess(true);
          setTimeout(() => setUploadSuccess(false), 3000);
        } catch (err) {
          const errorInfo = analyzeImageError(err, failedFile.file.size, failedFile.name);
          setUploadError(`Retry failed: ${errorInfo.advice}`);
        }

        setUploading(false);
      };

      const deleteImage = async (id) => {
        await saveImages(images.filter(img => img.id !== id));
      };

      const downloadImage = (image) => {
        const link = document.createElement('a');
        link.href = image.base64;
        link.download = image.name;
        link.click();
      };

      const handleTouchStart = (e) => {
        setTouchStart(e.targetTouches[0].clientX);
      };

      const handleTouchMove = (e) => {
        setTouchEnd(e.targetTouches[0].clientX);
      };

      const handleTouchEnd = (currentGroup) => {
        if (!touchStart || !touchEnd) return;
        const distance = touchStart - touchEnd;
        const isLeftSwipe = distance > 50;
        const isRightSwipe = distance < -50;

        if (isLeftSwipe && innerSlideIndex < currentGroup.length - 1) {
          setInnerSlideIndex(innerSlideIndex + 1);
        }
        if (isRightSwipe && innerSlideIndex > 0) {
          setInnerSlideIndex(innerSlideIndex - 1);
        }
        setTouchStart(0);
        setTouchEnd(0);
      };

      const handleMouseDown = (e) => {
        setTouchStart(e.clientX);
      };

      const handleMouseMove = (e) => {
        if (touchStart) {
          setTouchEnd(e.clientX);
        }
      };

      const handleMouseUp = (currentGroup) => {
        if (!touchStart || !touchEnd) {
          setTouchStart(0);
          setTouchEnd(0);
          return;
        }
        const distance = touchStart - touchEnd;
        const isLeftSwipe = distance > 50;
        const isRightSwipe = distance < -50;

        if (isLeftSwipe && innerSlideIndex < currentGroup.length - 1) {
          setInnerSlideIndex(innerSlideIndex + 1);
        }
        if (isRightSwipe && innerSlideIndex > 0) {
          setInnerSlideIndex(innerSlideIndex - 1);
        }
        setTouchStart(0);
        setTouchEnd(0);
      };

      if (loading) return <div className="flex items-center justify-center min-h-screen bg-slate-900 text-white">Loading...</div>;

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 p-6">
          <div className="max-w-6xl mx-auto">
            <h1 className="text-4xl font-bold text-white mb-6">Random Image Storage</h1>

            <div className="flex gap-4 border-b border-slate-700 mb-6">
              <button onClick={() => setActiveTab('home')} className={`px-6 py-3 font-semibold ${activeTab === 'home' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-slate-400'}`}>Home</button>
              <button onClick={() => setActiveTab('gallery')} className={`px-6 py-3 font-semibold ${activeTab === 'gallery' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-slate-400'}`}>Images ({images.length})</button>
            </div>

            {error && <div className="mb-6 bg-red-900/30 border border-red-700 rounded-lg p-4 text-red-200"><AlertCircle className="inline mr-2" size={20} />{error}</div>}

            {uploading && (
              <div className="mb-6 bg-blue-900/30 border border-blue-700 rounded-lg p-4 text-blue-200">
                <div className="flex items-center gap-3">
                  <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-400"></div>
                  <span>Uploading images...</span>
                </div>
              </div>
            )}

            {uploadSuccess && uploadStats && (
              <div className="mb-6 bg-green-900/30 border border-green-700 rounded-lg p-4 text-green-200">
                <div className="flex items-center gap-3">
                  <span className="text-2xl">‚úì</span>
                  <span className="font-semibold">{uploadStats.count} image{uploadStats.count > 1 ? 's' : ''} uploaded successfully!</span>
                </div>
              </div>
            )}

            {uploadError && failedFiles.length > 0 && (
              <div className="mb-6 bg-yellow-900/30 border border-yellow-700 rounded-lg p-4">
                <div className="flex items-center gap-3 mb-3">
                  <AlertCircle className="text-yellow-400" size={20} />
                  <span className="text-yellow-200 font-semibold">{uploadError}</span>
                </div>
                <div className="space-y-3">
                  {failedFiles.map((failed, idx) => (
                    <div key={idx} className="bg-slate-800/50 rounded-lg p-3">
                      <p className="text-white font-semibold text-sm mb-1">{failed.name}</p>
                      <p className="text-yellow-300 text-xs mb-2">
                        <strong>{failed.reason}:</strong> {failed.advice}
                      </p>
                      <button
                        onClick={() => retryFailedUpload(failed)}
                        disabled={uploading}
                        className="bg-blue-600 hover:bg-blue-700 disabled:opacity-50 text-white px-3 py-1 rounded text-xs font-semibold"
                      >
                        üîÑ Retry Upload
                      </button>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {activeTab === 'home' && (
              <div>
                <p className="text-slate-300 mb-6">Upload and organize your screenshots</p>

                <div className="flex gap-4 mb-6">
                  <div className="bg-slate-700/50 rounded-lg p-4 flex-1"><p className="text-slate-400 text-sm">Total Images</p><p className="text-2xl font-bold text-white">{images.length}</p></div>
                  <div className="bg-slate-700/50 rounded-lg p-4 flex-1"><p className="text-slate-400 text-sm">Total Storage</p><p className="text-2xl font-bold text-white">{(images.reduce((s, img) => s + parseFloat(img.size), 0) / 1024).toFixed(2)} MB</p></div>
                </div>
                <button onClick={() => {const s = [...images].sort(() => Math.random() - 0.5); setShuffledImages(s); setCurrentSlideIndex(0); setRandomSlideshow(true);}} disabled={images.length === 0} className="w-full bg-purple-600 hover:bg-purple-700 disabled:opacity-50 text-white font-semibold py-3 px-4 rounded-lg">üé≤ Random Slideshow</button>
              </div>
            )}

            {activeTab === 'gallery' && (
              <div>
                <div className="mb-6 bg-slate-700/50 rounded-lg p-4">
                  <p className="text-white font-semibold mb-3">Category</p>
                  <div className="flex gap-3">
                    <button onClick={() => setSelectedCategory('1')} className={`px-6 py-2 rounded font-semibold transition-colors ${selectedCategory === '1' ? 'bg-red-600 text-white' : 'bg-slate-600 text-slate-300 hover:bg-slate-500'}`}>1</button>
                    <button onClick={() => setSelectedCategory('2')} className={`px-6 py-2 rounded font-semibold transition-colors ${selectedCategory === '2' ? 'bg-blue-600 text-white' : 'bg-slate-600 text-slate-300 hover:bg-slate-500'}`}>2</button>
                    <button onClick={() => setSelectedCategory('3')} className={`px-6 py-2 rounded font-semibold transition-colors ${selectedCategory === '3' ? 'bg-yellow-600 text-white' : 'bg-slate-600 text-slate-300 hover:bg-slate-500'}`}>3</button>
                  </div>
                </div>

                <div className="mb-6">
                  <label className="block">
                    <div className="bg-slate-700/50 border-2 border-dashed border-slate-600 hover:border-blue-500 rounded-lg p-8 cursor-pointer">
                      <div className="flex flex-col items-center gap-3">
                        <Upload className="text-blue-400" size={36} />
                        <div className="text-center">
                          <p className="text-white font-semibold">Click to upload images</p>
                        </div>
                      </div>
                      <input type="file" multiple accept="image/*" onChange={handleImageUpload} disabled={uploading} className="hidden" />
                    </div>
                  </label>
                </div>

                <button onClick={() => setShowDeleteAllPrompt(true)} disabled={images.length === 0} className="mb-4 bg-red-600 hover:bg-red-700 disabled:opacity-50 text-white px-4 py-2 rounded text-sm font-semibold">üóëÔ∏è Delete All</button>

                {showDeleteAllPrompt && (
                  <div className="fixed inset-0 bg-black/80 flex items-center justify-center p-4 z-40">
                    <div className="bg-slate-800 rounded-lg p-6 max-w-sm">
                      <p className="text-white mb-4">Enter yes code:</p>
                      <input type="text" placeholder="Code..." value={deleteAllCode} onChange={(e) => setDeleteAllCode(e.target.value)} className="w-full bg-slate-700 text-white px-4 py-2 rounded mb-4 border border-slate-600" />
                      <div className="flex gap-2">
                        <button onClick={async () => {if (deleteAllCode === 'yes') {await saveImages([]); setDeleteAllCode(''); setShowDeleteAllPrompt(false);} else {alert('Wrong code!');}}} className="flex-1 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded">Delete All</button>
                        <button onClick={() => {setDeleteAllCode(''); setShowDeleteAllPrompt(false);}} className="flex-1 bg-slate-600 hover:bg-slate-700 text-white px-4 py-2 rounded">Cancel</button>
                      </div>
                    </div>
                  </div>
                )}

                {images.length === 0 ? (
                  <div className="text-center py-12 bg-slate-700/30 rounded-lg"><p className="text-slate-400">No images yet</p></div>
                ) : (
                  <div className="space-y-2">
                    {images.map((img, idx) => {
                      let groupLabel = null;
                      if (img.groupSize > 1) {
                        const groupIds = new Set();
                        let groupNum = 0;
                        for (let i = 0; i < images.length; i++) {
                          if (images[i].groupSize > 1 && !groupIds.has(images[i].groupId)) {
                            groupIds.add(images[i].groupId);
                            groupNum++;
                            if (images[i].groupId === img.groupId) break;
                          }
                        }
                        groupLabel = `G${groupNum}`;
                      }
                      return (
                        <div key={img.id} className="bg-slate-700/50 rounded-lg p-4 flex items-center justify-between hover:bg-slate-700/70">
                          <div className="flex items-center gap-3">
                            <p className="text-white font-semibold text-lg">{idx + 1}</p>
                            {groupLabel && <span className="bg-purple-600 text-white text-xs px-3 py-1 rounded font-semibold">{groupLabel}</span>}
                            <span className={`text-white text-xs px-3 py-1 rounded font-semibold ${img.category === '1' ? 'bg-red-600' : img.category === '3' ? 'bg-yellow-600' : 'bg-blue-600'}`}>{img.category}</span>
                          </div>
                          <div className="flex gap-2">
                            <button onClick={() => setViewingImage(img)} className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded text-sm">View</button>
                            <button onClick={() => downloadImage(img)} className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded text-sm flex items-center gap-2"><Download size={14} /> DL</button>
                            <button onClick={() => deleteImage(img.id)} className="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded"><Trash2 size={16} /></button>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            )}

            {viewingImage && !randomSlideshow && (
              <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4" onClick={() => setViewingImage(null)}>
                <div className="bg-slate-800 rounded-lg w-full max-w-2xl max-h-[75vh] flex flex-col" onClick={(e) => e.stopPropagation()}>
                  <div className="flex-1 overflow-auto flex items-center justify-center p-4 min-h-0">
                    <img src={viewingImage.base64} alt={viewingImage.name} className="max-w-full max-h-full object-contain" />
                  </div>
                  <div className="border-t border-slate-700 p-2 flex gap-1 items-center justify-between flex-shrink-0">
                    <p className="text-slate-400 text-xs">{images.findIndex(img => img.id === viewingImage.id) + 1} / {images.length}</p>
                    <div className="flex gap-1">
                      <button onClick={() => {const idx = images.findIndex(img => img.id === viewingImage.id); if (idx > 0) setViewingImage(images[idx - 1]);}} disabled={images.findIndex(img => img.id === viewingImage.id) === 0} className="bg-slate-600 hover:bg-slate-700 disabled:opacity-50 text-white px-2 py-1 rounded text-xs">‚óÄ Prev</button>
                      <button onClick={() => {const idx = images.findIndex(img => img.id === viewingImage.id); if (idx < images.length - 1) setViewingImage(images[idx + 1]);}} disabled={images.findIndex(img => img.id === viewingImage.id) === images.length - 1} className="bg-slate-600 hover:bg-slate-700 disabled:opacity-50 text-white px-2 py-1 rounded text-xs">Next ‚ñ∂</button>
                      <button onClick={() => downloadImage(viewingImage)} className="bg-blue-600 hover:bg-blue-700 text-white px-2 py-1 rounded text-xs">DL</button>
                      <button onClick={() => setViewingImage(null)} className="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-xs">Close</button>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {randomSlideshow && shuffledImages.length > 0 && (
              <div className="fixed inset-0 bg-black/80 flex flex-col items-center justify-center z-50 p-4" onClick={() => {setRandomSlideshow(false); setShuffledImages([]); setCurrentSlideIndex(0);}}>
                <div className="mb-4 flex gap-2" onClick={(e) => e.stopPropagation()}>
                  <button onClick={(e) => {e.stopPropagation(); setFilterCategory('ALL'); setCurrentSlideIndex(0);}} className={`px-4 py-2 rounded font-semibold ${filterCategory === 'ALL' ? 'bg-white text-black' : 'bg-slate-600 text-white'}`}>ALL</button>
                  <button onClick={(e) => {e.stopPropagation(); setFilterCategory('1'); setCurrentSlideIndex(0);}} className={`px-4 py-2 rounded font-semibold ${filterCategory === '1' ? 'bg-red-600 text-white' : 'bg-slate-600 text-white'}`}>1</button>
                  <button onClick={(e) => {e.stopPropagation(); setFilterCategory('2'); setCurrentSlideIndex(0);}} className={`px-4 py-2 rounded font-semibold ${filterCategory === '2' ? 'bg-blue-600 text-white' : 'bg-slate-600 text-white'}`}>2</button>
                  <button onClick={(e) => {e.stopPropagation(); setFilterCategory('3'); setCurrentSlideIndex(0);}} className={`px-4 py-2 rounded font-semibold ${filterCategory === '3' ? 'bg-yellow-600 text-white' : 'bg-slate-600 text-white'}`}>3</button>
                </div>
                <div className="bg-slate-800 rounded-lg w-full max-w-4xl max-h-[85vh] flex flex-col relative" onClick={(e) => e.stopPropagation()}>
                  {(() => {
                    const filtered = filterCategory === 'ALL' ? shuffledImages : shuffledImages.filter(img => img.category === filterCategory);
                    if (filtered.length === 0) return <div className="flex-1 flex items-center justify-center text-slate-400">No images in this category</div>;
                    
                    const groupedSlides = [];
                    const processedGroupIds = new Set();
                    
                    filtered.forEach(img => {
                      if (img.groupSize > 1) {
                        if (!processedGroupIds.has(img.groupId)) {
                          processedGroupIds.add(img.groupId);
                          groupedSlides.push(filtered.filter(i => i.groupId === img.groupId).sort((a, b) => (a.groupOrder || 0) - (b.groupOrder || 0)));
                        }
                      } else {
                        groupedSlides.push([img]);
                      }
                    });
                    
                    const currentGroupIndex = currentSlideIndex;
                    
                    if (groupedSlides.length === 0) return <div className="flex-1 flex items-center justify-center text-slate-400">No images</div>;
                    
                    const currentGroup = groupedSlides[currentGroupIndex] || groupedSlides[0];
                    const currentImg = currentGroup[innerSlideIndex] || currentGroup[0];
                    
                    return (
                      <>
                        <button onClick={(e) => {e.stopPropagation(); setRandomSlideshow(false); setShuffledImages([]); setCurrentSlideIndex(0);}} className="absolute top-3 right-3 z-10 bg-red-600/75 hover:bg-red-700/75 text-white w-10 h-10 rounded-full flex items-center justify-center text-xl font-bold">√ó</button>
                        <div 
                          className="flex-1 overflow-auto flex items-center justify-center p-3 min-h-0 relative select-none"
                          onTouchStart={handleTouchStart}
                          onTouchMove={handleTouchMove}
                          onTouchEnd={() => handleTouchEnd(currentGroup)}
                          onMouseDown={handleMouseDown}
                          onMouseMove={handleMouseMove}
                          onMouseUp={() => handleMouseUp(currentGroup)}
                          onMouseLeave={() => {setTouchStart(0); setTouchEnd(0);}}
                        >
                          <img src={currentImg.base64} alt="slide" className="max-w-full max-h-full object-contain pointer-events-none" />
                          <button onClick={(e) => {e.stopPropagation(); if (currentGroupIndex > 0) setCurrentSlideIndex(currentGroupIndex - 1);}} disabled={currentGroupIndex === 0} className="absolute left-3 top-1/2 -translate-y-1/2 bg-slate-800/25 hover:bg-slate-700/25 disabled:opacity-30 text-white w-12 h-12 rounded-full flex items-center justify-center text-2xl font-bold">‚Äπ</button>
                          <button onClick={(e) => {e.stopPropagation(); if (currentGroupIndex < groupedSlides.length - 1) setCurrentSlideIndex(currentGroupIndex + 1);}} disabled={currentGroupIndex === groupedSlides.length - 1} className="absolute right-3 top-1/2 -translate-y-1/2 bg-slate-800/25 hover:bg-slate-700/25 disabled:opacity-30 text-white w-12 h-12 rounded-full flex items-center justify-center text-2xl font-bold">‚Ä∫</button>
                          <div className="absolute bottom-3 left-1/2 -translate-x-1/2 bg-slate-800/90 text-slate-300 px-3 py-1 rounded-full text-sm">{currentGroupIndex + 1} / {groupedSlides.length}</div>
                        </div>
                        {currentGroup.length > 1 && (
                          <div className="flex justify-center gap-2 py-2 bg-slate-700/50">
                            {currentGroup.map((_, i) => (
                              <button key={i} onClick={() => setInnerSlideIndex(i)} className={`w-3 h-3 rounded-full ${i === innerSlideIndex ? 'bg-blue-400' : 'bg-slate-400 hover:bg-slate-300'}`} />
                            ))}
                          </div>
                        )}
                      </>
                    );
                  })()}
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<ImageStorage />, document.getElementById('root'));
  </script>
</body>
</html>
